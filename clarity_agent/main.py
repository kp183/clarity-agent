import typer
import asyncio
import json
import re
from rich.console import Console
from rich.panel import Panel
from rich.syntax import Syntax
from typing_extensions import Annotated
from typing import List, Tuple, Optional

# These imports are all correct
from .mcp_server.server import start_mcp_server
from .utils.logging import logger
from .agents.analyst import AnalystAgent
from .agents.sentinel import SentinelAgent
from .agents.copilot import CoPilotAgent

# --- Initialization (Correct) ---
app = typer.Typer()
console = Console()

# --- Helper Functions ---

async def _run_analysis_workflow(log_files: List[str]) -> Tuple[Optional[Panel], Optional[Panel], str, str, AnalystAgent]:
    """
    Reusable analysis workflow that returns analysis results for both analyze and ticket commands.
    
    Returns:
        Tuple of (report_panel, remediation_panel, analysis_str, remediation_command, agent)
    """
    with console.status("[bold blue]üöÄ Initializing Clarity Agent...[/bold blue]", spinner="dots") as status:
        
        status.update("[bold blue]üìä Parsing and consolidating log files...[/bold blue]")
        agent = AnalystAgent()
        
        # Pass the status object to the agent for dynamic updates
        report_panel, remediation_panel = await agent.run_analysis(log_files, status)
        
        status.update("[bold green]‚ú® Finalizing analysis report...[/bold green]")
        
        # Get the raw analysis data for ticket formatting
        copilot_data = agent.get_analysis_data_for_copilot()
        analysis_str = copilot_data.get("analysis_result", "") if copilot_data else ""
        remediation_command = copilot_data.get("remediation_command", "") if copilot_data else ""
        
    return report_panel, remediation_panel, analysis_str, remediation_command, agent

def _format_for_ticketing(analysis_str: str, remediation_command: str) -> str:
    """
    Formats analysis results into a professional Markdown ticket update.
    
    Args:
        analysis_str: Raw JSON analysis string from the AI
        remediation_command: Suggested remediation command
        
    Returns:
        Formatted Markdown string suitable for ticketing systems
    """
    # Extract JSON data from analysis string
    try:
        # Try to extract JSON from the analysis string
        json_match = re.search(r'\{.*\}', analysis_str, re.DOTALL)
        if json_match:
            analysis_data = json.loads(json_match.group(0))
        else:
            # Fallback if no JSON found
            analysis_data = {
                "summary": "Analysis data unavailable",
                "root_cause_description": "Could not parse analysis results",
                "affected_components": ["unknown"],
                "confidence_score": 0.0
            }
    except (json.JSONDecodeError, AttributeError):
        # Fallback for invalid JSON
        analysis_data = {
            "summary": "Analysis parsing error",
            "root_cause_description": "Could not parse analysis results from AI response",
            "affected_components": ["unknown"],
            "confidence_score": 0.0
        }
    
    # Build the Markdown ticket content
    markdown_content = f"""### ü§ñ AI-Powered Incident Report

**Summary:** {analysis_data.get('summary', 'N/A')}

**Root Cause Analysis:**
{analysis_data.get('root_cause_description', 'N/A')}

**Affected Components:**
{chr(10).join(f'‚Ä¢ {component}' for component in analysis_data.get('affected_components', ['unknown']))}

**AI Confidence Score:** {analysis_data.get('confidence_score', 0.0):.1%}

**Recommended Remediation:**
```bash
{remediation_command}
```

**Analysis Generated:** {__import__('datetime').datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}

---
*This report was generated by Clarity Agent using AWS Bedrock AI analysis*"""

    return markdown_content

# --- Commands ---

@app.command()
def version():
    """Shows the application version."""
    console.print("Clarity Agent v0.1.0")

@app.command()
def start_mcp():
    """Starts the MCP server for remediation tools."""
    console.print("[bold green]Starting Clarity Agent MCP Server...[/bold green]")
    try:
        # THE FIX IS HERE: We directly call the function now, as it is no longer async.
        # Uvicorn handles the event loop internally.
        start_mcp_server()
    except KeyboardInterrupt:
        # Uvicorn will print its own shutdown message, but this is good for catching an early exit.
        console.print("\n[bold yellow]MCP Server shut down by user.[/bold yellow]")

@app.command()
def analyze(
    log_files: Annotated[List[str], typer.Argument(help="A list of log file paths to analyze.")]
):
    """Runs the reactive incident analysis using the Analyst Agent."""
    
    async def run_async_analysis():
        # Use the new reusable workflow function - but we need to get the agent instance back
        with console.status("[bold blue]üöÄ Initializing Clarity Agent...[/bold blue]", spinner="dots") as status:
            
            status.update("[bold blue]üìä Parsing and consolidating log files...[/bold blue]")
            agent = AnalystAgent()
            
            # Pass the status object to the agent for dynamic updates
            report_panel, remediation_panel = await agent.run_analysis(log_files, status)
            
            status.update("[bold green]‚ú® Finalizing analysis report...[/bold green]")
        
        console.print("\n")
        console.print("üéØ [bold green]Analysis Complete[/bold green] üéØ")
        console.print()
        
        # Display the professional panels
        if report_panel:
            console.print(report_panel)
            console.print()
        if remediation_panel:
            console.print(remediation_panel)
            console.print()
        
        # Offer Co-Pilot interactive session
        from rich.prompt import Confirm
        if Confirm.ask("[bold cyan]ü§ñ Would you like to start an interactive investigation with the Co-Pilot Agent?[/bold cyan]"):
            console.print()
            
            # Use the same agent instance that ran the analysis
            copilot_data = agent.get_analysis_data_for_copilot()
            if copilot_data:
                copilot = CoPilotAgent()
                copilot.start_interactive_session(
                    incident_data={"log_files": log_files},
                    timeline_data=copilot_data["timeline_data"],
                    analysis_result=copilot_data["analysis_result"]
                )
            else:
                console.print("[red]No analysis data available for Co-Pilot session.[/red]")

    # Use asyncio.run() to execute our async top-level function
    asyncio.run(run_async_analysis())

@app.command()
def ticket(
    log_files: Annotated[List[str], typer.Argument(help="A list of log file paths to analyze for ticket generation.")]
):
    """Generates a professional incident report formatted for ticketing systems like Jira or ServiceNow."""
    
    async def run_async_ticket_generation():
        # Use the reusable workflow function
        report_panel, remediation_panel, analysis_str, remediation_command, agent = await _run_analysis_workflow(log_files)
        
        console.print("\n")
        console.print("üéØ [bold green]Analysis Complete[/bold green] üéØ")
        console.print()
        
        # Display the professional panels (same as analyze command)
        if report_panel:
            console.print(report_panel)
            console.print()
        if remediation_panel:
            console.print(remediation_panel)
            console.print()
        
        # Generate and display the formatted ticket content
        ticket_markdown = _format_for_ticketing(analysis_str, remediation_command)
        
        ticket_panel = Panel(
            Syntax(ticket_markdown, "markdown", theme="monokai", word_wrap=True),
            title="[bold blue]üìã Formatted Ticket Update (Copy Below)[/bold blue]",
            subtitle="[dim]Ready for Jira, ServiceNow, or other ticketing systems[/dim]",
            border_style="blue",
            expand=True,
            padding=(1, 2)
        )
        
        console.print(ticket_panel)
        console.print()
        console.print("[dim]üí° Tip: Copy the content above and paste it directly into your incident ticket[/dim]")

    # Use asyncio.run() to execute our async top-level function
    asyncio.run(run_async_ticket_generation())

@app.command()
def monitor(
    log_files: Annotated[List[str], typer.Argument(help="A list of log file paths to monitor for trends.")]
):
    """Starts proactive monitoring using the Sentinel Agent to detect trends before they become incidents."""
    
    async def run_async_monitoring():
        with console.status("[bold green]üõ°Ô∏è Initializing Sentinel Agent for proactive monitoring...[/bold green]", spinner="dots") as status:
            
            status.update("[bold blue]üîß Setting up monitoring infrastructure...[/bold blue]")
            sentinel = SentinelAgent()
            
            console.print("\n")
            console.print("üõ°Ô∏è [bold green]Sentinel Agent Activated[/bold green] üõ°Ô∏è")
            console.print("[dim]Press Ctrl+C to stop monitoring[/dim]")
            console.print()
            
            # Start monitoring (this will run until interrupted)
            await sentinel.start_monitoring(log_files, status)
            
        console.print("\n")
        console.print("üõë [bold yellow]Proactive Monitoring Stopped[/bold yellow]")

    # Use asyncio.run() to execute our async monitoring function
    asyncio.run(run_async_monitoring())

# --- Application Entry Point (Correct) ---
if __name__ == "__main__":
    app()